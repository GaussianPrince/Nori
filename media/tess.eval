
layout(triangles, equal_spacing, ccw) in;
in vec3 tcPosition[];
in vec3 tcNormal[];
out vec3 tePosition;
out vec3 teNormal;
out vec3 tePatchDistance;

#define tc gl_TessCoord

// <1.0 - Less roundness when approaching zero
// ~1.0 ~ Sphere
// >1.0 - Original polygons pop out
const float exaggeration = 0.8;

void main()
{
  // Used for patch visualization
  tePatchDistance = gl_TessCoord;

  // Trivial point location
  vec3 p0 = tc.x * tcPosition[0];
  vec3 p1 = tc.y * tcPosition[1];
  vec3 p2 = tc.z * tcPosition[2];
  tePosition = p0 + p1 + p2;

  // Trivial normal
  vec3 n0 = tc.x * tcNormal[0];
  vec3 n1 = tc.y * tcNormal[1];
  vec3 n2 = tc.z * tcNormal[2];
  teNormal = normalize(n0 + n1 + n2);

  // Calculate distance to each edge
  float d0 = tc.y * tc.z;
  float d1 = tc.x * tc.z;
  float d2 = tc.x * tc.y;

  // Calculate curvature factors for each edge
  // Uses the angles between the corner normals of the patch
  vec3 nn0 = normalize(tcNormal[0]);
  vec3 nn1 = normalize(tcNormal[1]);
  vec3 nn2 = normalize(tcNormal[2]);
  float f0 = 1.0 - dot(nn0, nn1);
  float f1 = 1.0 - dot(nn1, nn2);
  float f2 = 1.0 - dot(nn2, nn0);

  // Adjust the curvature based on distance to the edge
  f0 *= d2;
  f1 *= d0;
  f2 *= d1;

  // Calculate total displacement
  float f = exaggeration * (f0 + f1 + f2);

  // Displace
  tePosition += f * teNormal;

  // Covert to model view space
  teNormal = (wyMV * vec4(teNormal, 0.0)).xyz;
  gl_Position = wyMVP * vec4(tePosition, 1);
}

